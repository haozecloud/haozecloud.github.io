<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>docker-cheat-sheet - 原点独白</title>

  
    <meta name="description" content="Docker Cheat Sheet 内容主要搬迁自：Docker Cheat Sheet     为何使用 Docker 运维 容器(Container) 镜像(Images) 网络(Networks) 仓管中心和仓库(Registry &amp; Repository) Dockerfile 层(Layers) 链接(Links) 卷标(Volumes) 暴露端口(Exposing ports">
<meta property="og:type" content="article">
<meta property="og:title" content="docker-cheat-sheet">
<meta property="og:url" content="https://www.haozecloud.tech/2023/09/28/Linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/docker/docker-cheat-sheet/index.html">
<meta property="og:site_name" content="原点独白">
<meta property="og:description" content="Docker Cheat Sheet 内容主要搬迁自：Docker Cheat Sheet     为何使用 Docker 运维 容器(Container) 镜像(Images) 网络(Networks) 仓管中心和仓库(Registry &amp; Repository) Dockerfile 层(Layers) 链接(Links) 卷标(Volumes) 暴露端口(Exposing ports">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-27T18:23:40.000Z">
<meta property="article:modified_time" content="2023-09-28T06:23:40.426Z">
<meta property="article:author" content="Zhang Hao Ze">
<meta name="twitter:card" content="summary">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://img1.imgtp.com/2023/09/25/3pQ59aAI.png">
  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://img1.imgtp.com/2023/09/25/3pQ59aAI.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">原点独白</div><div class="sub cap">微信公众号</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/images/">照片</a><a class="nav-item" href="/more/">日常</a></nav>
</header>


<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">docker-cheat-sheet</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8-Docker"><span class="toc-text">为何使用 Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4"><span class="toc-text">运维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%89%88%E6%9C%AC"><span class="toc-text">检查版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%8A%A0%E9%80%9F"><span class="toc-text">Docker 加速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-Container"><span class="toc-text">容器(Container)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2"><span class="toc-text">启动和停止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E9%99%90%E5%88%B6"><span class="toc-text">CPU 限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6"><span class="toc-text">内存限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B-Capabilities"><span class="toc-text">能力(Capabilities)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF"><span class="toc-text">信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BA"><span class="toc-text">导入 &#x2F; 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">执行命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F-Images"><span class="toc-text">镜像(Images)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E4%BF%A1%E6%81%AF"><span class="toc-text">其它信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%90%86"><span class="toc-text">清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-%E4%BF%9D%E5%AD%98%E9%95%9C%E5%83%8F"><span class="toc-text">加载 &#x2F; 保存镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">导入 &#x2F; 导出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%B7%B2%E4%BF%9D%E5%AD%98%E7%9A%84%E9%95%9C%E5%83%8F-%E4%B8%8E-%E5%AF%BC%E5%85%A5%E5%B7%B2%E5%AF%BC%E5%87%BA%E4%B8%BA%E9%95%9C%E5%83%8F%E7%9A%84%E5%AE%B9%E5%99%A8-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">加载已保存的镜像 与 导入已导出为镜像的容器 的不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-Networks"><span class="toc-text">网络(Networks)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E4%BF%A1%E6%81%AF-1"><span class="toc-text">其它信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">建立连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3-Exposing-ports"><span class="toc-text">暴露端口(Exposing ports)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%93%E7%AE%A1%E4%B8%AD%E5%BF%83%E5%92%8C%E4%BB%93%E5%BA%93-Registry-Repository"><span class="toc-text">仓管中心和仓库(Registry &amp; Repository)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BB%93%E7%AE%A1%E4%B8%AD%E5%BF%83"><span class="toc-text">本地仓管中心</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile"><span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%99%E7%A8%8B"><span class="toc-text">教程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82-Layers"><span class="toc-text">层(Layers)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5-Links"><span class="toc-text">链接(Links)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B7%E6%A0%87-Volumes-%E5%92%8C%E6%8C%82%E8%BD%BD"><span class="toc-text">卷标(Volumes)和挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E6%A0%87"><span class="toc-text">卷标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-text">挂载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8-Security"><span class="toc-text">安全(Security)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%8F%90%E7%A4%BA"><span class="toc-text">安全提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-User-Namespaces"><span class="toc-text">用户命名空间(User Namespaces)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E8%A7%86%E9%A2%91"><span class="toc-text">安全相关视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%B7%AF%E7%BA%BF%E5%9B%BE"><span class="toc-text">安全路线图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%B4%B4%E5%A3%AB"><span class="toc-text">小贴士</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%90%86-1"><span class="toc-text">清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#df-%E5%91%BD%E4%BB%A4"><span class="toc-text">df 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heredoc-%E5%A3%B0%E6%98%8E-Docker-%E5%AE%B9%E5%99%A8"><span class="toc-text">Heredoc 声明 Docker 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AE%B9%E5%99%A8-ID"><span class="toc-text">最近一次的容器 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8F%90%E4%BA%A4%EF%BC%88%E9%9C%80%E8%A6%81-Dockerfile%EF%BC%89"><span class="toc-text">带命令的提交（需要 Dockerfile）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80"><span class="toc-text">获取 IP 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-text">获取端口映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E5%AE%B9%E5%99%A8"><span class="toc-text">通过正则匹配容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE"><span class="toc-text">获取环境变量配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%A1%8C%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">强行终止运行中的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8%EF%BC%88%E5%BC%BA%E8%A1%8C%E5%88%A0%E9%99%A4%EF%BC%81%E6%97%A0%E8%AE%BA%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%88%96%E5%81%9C%E6%AD%A2%EF%BC%89"><span class="toc-text">删除所有容器（强行删除！无论容器运行或停止）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%97%A7%E5%AE%B9%E5%99%A8"><span class="toc-text">删除旧容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">删除已停止的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%B9%B6%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-text">停止并删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%97%A0%E7%94%A8-dangling-%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">删除无用 (dangling) 的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E9%95%9C%E5%83%8F"><span class="toc-text">删除所有镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%97%A0%E7%94%A8-dangling-%E7%9A%84%E5%8D%B7%E6%A0%87"><span class="toc-text">删除无用 (dangling) 的卷标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E4%BE%9D%E8%B5%96"><span class="toc-text">查看镜像依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E7%98%A6%E8%BA%AB"><span class="toc-text">Docker 容器瘦身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E8%BF%90%E8%A1%8C%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-text">监视运行中容器的系统资源利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD%E4%B8%BA%E5%8D%B7%E6%A0%87"><span class="toc-text">将文件挂载为卷标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div></div></widget>



<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" placeholder="站内搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/08a41b181ce68.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3845874.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3616429.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://images.cnblogs.com/cnblogs_com/mant/1674402/o_230928074314_%E9%92%89%E9%92%89.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">Linux配置文件</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/Linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/docker/">docker</a></div><div id="post-meta">发布于&nbsp;<time datetime="2023-09-27T18:23:40.000Z">2023-09-28</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>docker-cheat-sheet</span></h1>
<h1 id="Docker-Cheat-Sheet"><a href="#Docker-Cheat-Sheet" class="headerlink" title="Docker Cheat Sheet"></a>Docker Cheat Sheet</h1><blockquote>
<p>内容主要搬迁自：<a target="_blank" rel="noopener" href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn">Docker Cheat Sheet</a></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->

<ul>
<li><a href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8-docker">为何使用 Docker</a></li>
<li><a href="#%E8%BF%90%E7%BB%B4">运维</a></li>
<li><a href="#%E5%AE%B9%E5%99%A8container">容器(Container)</a></li>
<li><a href="#%E9%95%9C%E5%83%8Fimages">镜像(Images)</a></li>
<li><a href="#%E7%BD%91%E7%BB%9Cnetworks">网络(Networks)</a></li>
<li><a href="#%E4%BB%93%E7%AE%A1%E4%B8%AD%E5%BF%83%E5%92%8C%E4%BB%93%E5%BA%93registry--repository">仓管中心和仓库(Registry &amp; Repository)</a></li>
<li><a href="#dockerfile">Dockerfile</a></li>
<li><a href="#%E5%B1%82layers">层(Layers)</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5links">链接(Links)</a></li>
<li><a href="#%E5%8D%B7%E6%A0%87volumes">卷标(Volumes)</a></li>
<li><a href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3exposing-ports">暴露端口(Exposing ports)</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></li>
<li><a href="#%E5%AE%89%E5%85%A8security">安全(Security)</a></li>
<li><a href="#%E5%B0%8F%E8%B4%B4%E5%A3%AB">小贴士</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="为何使用-Docker"><a href="#为何使用-Docker" class="headerlink" title="为何使用 Docker"></a>为何使用 Docker</h2><p>「通过 Docker，开发者可以使用任何语言任何工具创建任何应用。“Dockerized” 的应用是完全可移植的，能在任何地方运行 - 不管是同事的 OS X 和 Windows 笔记本，或是在云端运行的 Ubuntu QA 服务，还是在虚拟机运行的 Red Hat 产品数据中心。</p>
<p>Docker Hub 上有 13000+ 的应用，开发者可以从中选取一个进行快速扩展开发。Docker 跟踪管理变更和依赖关系，让系统管理员能更容易理解开发人员是如何让应用运转起来的。而开发者可以通过 Docker Hub 的共有&#x2F;私有仓库，构建他们的自动化编译，与其他合作者共享成果。</p>
<p>Docker 帮助开发者更快地构建和发布高质量的应用。」—— <a target="_blank" rel="noopener" href="https://www.docker.com/what-docker/#copy1">什么是 Docker</a></p>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。</p>
<p>Docker CE 的安装请参考官方文档。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/install/">Mac</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/install/">Windows</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/fedora/">Fedora</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/binaries/">其他 Linux 发行版</a></li>
</ul>
<h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/version/"><code>docker version</code></a> 查看你正在运行的 Docker 版本。</p>
<p>获取 Docker 服务版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version --format &#x27;&#123;&#123;.Server.Version&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>你也可以输出原始的 JSON 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version --format &#x27;&#123;&#123;json .&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="Docker-加速"><a href="#Docker-加速" class="headerlink" title="Docker 加速"></a>Docker 加速</h3><p>国内访问 Docker Hub 很慢，所以，推荐配置 Docker 镜像仓库来提速。</p>
<p>镜像仓库清单：</p>
<table>
<thead>
<tr>
<th>镜像仓库</th>
<th>镜像仓库地址</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://daocloud.io/mirror">DaoCloud 镜像站</a></td>
<td><code>http://f1361db2.m.daocloud.io</code></td>
<td>开发者需要开通 DaoCloud 账户，然后可以得到专属加速器。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/">阿里云</a></td>
<td><code>https://yourcode.mirror.aliyuncs.com</code></td>
<td>开发者需要开通阿里开发者帐户，再使用阿里的加速服务。登录后阿里开发者帐户后，<code>https://cr.console.aliyun.com/undefined/instances/mirrors</code> 中查看你的您的专属加速器地址。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://c.163yun.com/hub">网易云</a></td>
<td><code>https://hub-mirror.c.163.com</code></td>
<td>直接配置即可，亲测较为稳定。</td>
</tr>
</tbody></table>
<p>配置镜像仓库方法（以 CentOS 为例）：</p>
<blockquote>
<p>下面的示例为在 CentOS 环境中，指定镜像仓库为 <code>https://hub-mirror.c.163.com</code></p>
</blockquote>
<p>（1）修改配置文件</p>
<p>修改 <code>/etc/docker/daemon.json</code> ，如果不存在则新建。执行以下 Shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">        &quot;https://hub-mirror.c.163.com&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>重启 docker 以生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>执行 <code>docker info</code> 命令，查看 <code>Registry Mirrors</code> 是否已被改为 <code>https://hub-mirror.c.163.com</code> ，如果是，则表示配置成功。</p>
<h2 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器(Container)"></a>容器(Container)</h2><p><a target="_blank" rel="noopener" href="http://etherealmind.com/basics-docker-containers-hypervisors-coreos/">关于 Docker 进程隔离的基础</a>。容器 (Container) 之于虚拟机 (Virtual Machine) 就好比线程之于进程。或者你可以把他们想成是「吃了类固醇的 chroots」。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/create"><code>docker create</code></a> 创建容器但不启动它。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/rename/"><code>docker rename</code></a> 用于重命名容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/run"><code>docker run</code></a> 一键创建并同时启动该容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/rm"><code>docker rm</code></a> 删除容器。<ul>
<li>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/update/"><code>docker update</code></a> 调整容器的资源限制。</li>
<li>清理掉所有处于终止状态的容器。</li>
</ul>
<p>通常情况下，不使用任何命令行选项启动一个容器，该容器将会立即启动并停止。若需保持其运行，你可以使用 <code>docker run -td container_id</code> 命令。选项 <code>-t</code> 表示分配一个 pseudo-TTY 会话，<code>-d</code> 表示自动将容器与终端分离（也就是说在后台运行容器，并输出容器 ID）。</p>
<p>如果你需要一个临时容器，可使用 <code>docker run --rm</code> 会在容器停止之后删除它。</p>
<p>如果你需要映射宿主机 (host) 的目录到 Docker 容器内，可使用 <code>docker run -v $HOSTDIR:$DOCKERDIR</code>。详见 <a target="_blank" rel="noopener" href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn#%E5%8D%B7%E6%A0%87volumes">卷标(Volumes)</a> 一节。</p>
<p>如果你想同时删除与容器相关联的卷标，那么在删除容器的时候必须包含 <code>-v</code> 选项，像这样 <code>docker rm -v</code>。</p>
<p>从 Docker 1.10 起，其内置一套各容器独立的 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/admin/logging/overview/">日志引擎</a>，每个容器可以独立使用。你可以使用 <code>docker run --log-driver=syslog</code> 来自定义日志引擎（例如以上的 <code>syslog</code>）。</p>
<h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/start"><code>docker start</code></a> 启动已存在的容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/stop"><code>docker stop</code></a> 停止运行中的容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/restart"><code>docker restart</code></a> 重启容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/pause/"><code>docker pause</code></a> 暂停运行中的容器，将其「冻结」在当前状态。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/unpause/"><code>docker unpause</code></a> 结束容器暂停状态。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/wait"><code>docker wait</code></a> 阻塞地等待某个运行中的容器直到停止。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/kill"><code>docker kill</code></a> 向运行中的容器发送 SIGKILL 指令。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/attach"><code>docker attach</code></a> 连接到运行中的容器。</li>
</ul>
<p>如果你想将容器的端口 (ports) 暴露至宿主机，请见 <a target="_blank" rel="noopener" href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3exposing-ports">暴露端口</a> 一节。</p>
<p>关于 Docker 实例崩溃后的重启策略，详见 <a target="_blank" rel="noopener" href="http://container42.com/2014/09/30/docker-restart-policies/">本文</a>。</p>
<h4 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h4><p>你可以限制 CPU 资源占用，无论是指定百分比，或是特定核心数。</p>
<p>例如，你可以设置 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/cpu-share-constraint"><code>cpu-shares</code></a>。该配置看起来有点奇怪 – 1024 表示 100% CPU，因此如果你希望容器使用所有 CPU 内核的 50%，应将其设置为 512：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --c 512 agileek/cpuset-test</span><br></pre></td></tr></table></figure>

<p>更多信息请参阅 <a target="_blank" rel="noopener" href="https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/#_cpu%E3%80%82">https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/#_cpu。</a></p>
<p>通过 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/cpuset-constraint"><code>cpuset-cpus</code></a> 可使用特定 CPU 内核。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --cpuset-cpus=0,4,6 agileek/cpuset-test</span><br></pre></td></tr></table></figure>

<p>请参阅 <a target="_blank" rel="noopener" href="https://agileek.github.io/docker/2014/08/06/docker-cpuset/">https://agileek.github.io/docker/2014/08/06/docker-cpuset/</a> 获取更多细节以及一些不错的视频。</p>
<p>注意，Docker 在容器内仍然能够 <strong>看到</strong> 全部 CPU – 它仅仅是不使用全部而已。请参阅 <a target="_blank" rel="noopener" href="https://github.com/docker/docker/issues/20770">https://github.com/docker/docker/issues/20770</a> 获取更多细节。</p>
<h4 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h4><p>同样，亦可给 Docker 设置 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/user-memory-constraints">内存限制</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 300M ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="能力-Capabilities"><a href="#能力-Capabilities" class="headerlink" title="能力(Capabilities)"></a>能力(Capabilities)</h4><p>Linux 的 Capability 可以通过使用 <code>cap-add</code> 和 <code>cap-drop</code> 设置。请参阅 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities">https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities</a> 获取更多细节。这有助于提高安全性。</p>
<p>如需要挂载基于 FUSE 的文件系统，你需要结合 <code>--cap-add</code> 和 <code>--device</code> 使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it --cap-add SYS_ADMIN --device /dev/fuse sshfs</span><br></pre></td></tr></table></figure>

<p>授予对某个设备的访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --device=/dev/ttyUSB0 debian bash</span><br></pre></td></tr></table></figure>

<p>授予对所有设备的访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged -v /dev/bus/usb:/dev/bus/usb debian bash</span><br></pre></td></tr></table></figure>

<p>有关容器特权的更多信息请参阅 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities">本文</a>。</p>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/ps"><code>docker ps</code></a> 查看运行中的所有容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/logs"><code>docker logs</code></a> 从容器中读取日志。（你也可以使用自定义日志驱动，不过在 1.10 中，它只支持 <code>json-file</code> 和 <code>journald</code>）。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/inspect"><code>docker inspect</code></a> 查看某个容器的所有信息（包括 IP 地址）。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/events"><code>docker events</code></a> 从容器中获取事件 (events)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/port"><code>docker port</code></a> 查看容器的公开端口。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/top"><code>docker top</code></a> 查看容器中活动进程。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/stats"><code>docker stats</code></a> 查看容器的资源使用量统计信息。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/diff"><code>docker diff</code></a> 查看容器文件系统中存在改动的文件。</li>
</ul>
<p><code>docker ps -a</code> 将显示所有容器，包括运行中和已停止的。</p>
<p><code>docker stats --all</code> 同样将显示所有容器，默认仅显示运行中的容器。</p>
<h3 id="导入-导出"><a href="#导入-导出" class="headerlink" title="导入 &#x2F; 导出"></a>导入 &#x2F; 导出</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/cp"><code>docker cp</code></a> 在容器和本地文件系统之间复制文件或目录。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/export"><code>docker export</code></a> 将容器的文件系统打包为归档文件流 (tarball archive stream) 并输出至标准输出 (STDOUT)。</li>
</ul>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/exec"><code>docker exec</code></a> 在容器内执行命令。</li>
</ul>
<p>例如，进入正在运行的 <code>foo</code> 容器，并连接 (attach) 到一个新的 Shell 进程：<code>docker exec -it foo /bin/bash</code>。</p>
<h2 id="镜像-Images"><a href="#镜像-Images" class="headerlink" title="镜像(Images)"></a>镜像(Images)</h2><p>镜像是 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/understanding-docker/#how-does-a-docker-image-work">Docker 容器的模板</a>。</p>
<h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/images"><code>docker images</code></a> 查看所有镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/import"><code>docker import</code></a> 从归档文件创建镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/build"><code>docker build</code></a> 从 Dockerfile 创建镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/commit"><code>docker commit</code></a> 为容器创建镜像，如果容器正在运行则会临时暂停。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/rmi"><code>docker rmi</code></a> 删除镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/load"><code>docker load</code></a> 从标准输入 (STDIN) 加载归档包 (tar archive) 作为镜像，包括镜像本身和标签 (tags, 0.7 起)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/save"><code>docker save</code></a> 将镜像打包为归档包，并输出至标准输出 (STDOUT)，包括所有的父层、标签和版本 (parent layers, tags, versions, 0.7 起)。</li>
</ul>
<h3 id="其它信息"><a href="#其它信息" class="headerlink" title="其它信息"></a>其它信息</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/history"><code>docker history</code></a> 查看镜像的历史记录。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/tag"><code>docker tag</code></a> 给镜像打标签命名（本地或者仓库均可）。</li>
</ul>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>虽然你可以用 <code>docker rmi</code> 命令来删除指定的镜像，不过有个名为 <a target="_blank" rel="noopener" href="https://github.com/spotify/docker-gc">docker-gc</a> 的工具，它可以以一种安全的方式，清理掉那些不再被任何容器使用的镜像。Docker 1.13 起，使用 <code>docker image prune</code> 亦可删除未使用的镜像。参见 <a target="_blank" rel="noopener" href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn#%E6%B8%85%E7%90%86">清理</a>。</p>
<h3 id="加载-保存镜像"><a href="#加载-保存镜像" class="headerlink" title="加载 &#x2F; 保存镜像"></a>加载 &#x2F; 保存镜像</h3><p>从文件中加载镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; my_image.tar.gz</span><br></pre></td></tr></table></figure>

<p>保存既有镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save my_image:my_tag | gzip &gt; my_image.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="导入-导出容器"><a href="#导入-导出容器" class="headerlink" title="导入 &#x2F; 导出容器"></a>导入 &#x2F; 导出容器</h3><p>从文件中导入容器镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_container.tar.gz | docker import - my_image:my_tag</span><br></pre></td></tr></table></figure>

<p>导出既有容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export my_container | gzip &gt; my_container.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="加载已保存的镜像-与-导入已导出为镜像的容器-的不同"><a href="#加载已保存的镜像-与-导入已导出为镜像的容器-的不同" class="headerlink" title="加载已保存的镜像 与 导入已导出为镜像的容器 的不同"></a>加载已保存的镜像 与 导入已导出为镜像的容器 的不同</h3><p>通过 <code>load</code> 命令来加载镜像，会创建一个新的镜像，并继承原镜像的所有历史。 通过 <code>import</code> 将容器作为镜像导入，也会创建一个新的镜像，但并不包含原镜像的历史，因此会比使用 <code>load</code> 方式生成的镜像更小。</p>
<h2 id="网络-Networks"><a href="#网络-Networks" class="headerlink" title="网络(Networks)"></a>网络(Networks)</h2><p>Docker 具备 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/">网络</a> 功能。我并不是很了解它，所以这是一个扩展本文的好地方。文档 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/work-with-networks/">使用网络</a> 指出，这是一种无需暴露端口即可实现 Docker 容器间通信的好方法。</p>
<h3 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_create/"><code>docker network create</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_rm/"><code>docker network rm</code></a></li>
</ul>
<h3 id="其它信息-1"><a href="#其它信息-1" class="headerlink" title="其它信息"></a>其它信息</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_ls/"><code>docker network ls</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_inspect/"><code>docker network inspect</code></a></li>
</ul>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_connect/"><code>docker network connect</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_disconnect/"><code>docker network disconnect</code></a></li>
</ul>
<p>你可以 <a target="_blank" rel="noopener" href="https://blog.jessfraz.com/post/ips-for-all-the-things/">为容器指定 IP 地址</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用你自己的子网和网关创建一个桥接网络</span><br><span class="line">docker network create --subnet 203.0.113.0/24 --gateway 203.0.113.254 iptastic</span><br><span class="line"></span><br><span class="line"># 基于以上创建的网络，运行一个 Nginx 容器并指定 IP</span><br><span class="line">$ docker run --rm -it --net iptastic --ip 203.0.113.2 nginx</span><br><span class="line"></span><br><span class="line"># 在其他地方使用 CURL 访问这个 IP（假设该 IP 为公网）</span><br><span class="line">$ curl 203.0.113.2</span><br></pre></td></tr></table></figure>

<h2 id="暴露端口-Exposing-ports"><a href="#暴露端口-Exposing-ports" class="headerlink" title="暴露端口(Exposing ports)"></a>暴露端口(Exposing ports)</h2><p>通过宿主容器暴露输入端口相当 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports">繁琐但有效的</a>。</p>
<p>例如使用 <code>-p</code> 将容器端口映射到宿主端口上（只使用本地主机 (localhost) 接口）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name CONTAINER -t someimage</span><br></pre></td></tr></table></figure>

<p>你可以使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a> 告知 Docker，该容器在运行时监听指定的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;CONTAINERPORT&gt;</span><br></pre></td></tr></table></figure>

<p>但是注意 EXPOSE 并不会直接暴露端口，你需要用参数 <code>-p</code> 。比如说你要在 localhost 上暴露容器的端口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A DOCKER -p tcp --dport &lt;LOCALHOSTPORT&gt; -j DNAT --to-destination &lt;CONTAINERIP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure>

<p>如果你是在 Virtualbox 中运行 Docker，那么你需要配置端口转发 (forward the port)。使用 <a target="_blank" rel="noopener" href="https://docs.vagrantup.com/v2/networking/forwarded_ports.html">forwarded_port</a> 在 Vagrantfile 上配置暴露的端口范围，这样你就可以动态地映射了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  (49000..49900).each do |port|</span><br><span class="line">    config.vm.network :forwarded_port, :host =&gt; port, :guest =&gt; port</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>如果你忘记了将什么端口映射到宿主机上的话，可使用 <code>docker port</code> 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port CONTAINER $CONTAINERPORT</span><br></pre></td></tr></table></figure>

<h2 id="仓管中心和仓库-Registry-Repository"><a href="#仓管中心和仓库-Registry-Repository" class="headerlink" title="仓管中心和仓库(Registry &amp; Repository)"></a>仓管中心和仓库(Registry &amp; Repository)</h2><p>仓库 (repository) 是 <em>被托管(hosted)</em> 的已命名镜像 (tagged images) 的集合，这组镜像用于构建容器文件系统。</p>
<p>仓管中心 (registry) 则是 <em>托管服务(host)</em> – 用于存储仓库并提供 HTTP API，以便 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockerrepos/">管理仓库的上传和下载</a>。</p>
<p>Docker 官方托管着自己的 <a target="_blank" rel="noopener" href="https://hub.docker.com/">仓管中心</a>，包含着数量众多的仓库。不过话虽如此，这个仓管中心 <a target="_blank" rel="noopener" href="https://titanous.com/posts/docker-insecurity">并没有很好地验证镜像</a>，所以如果你担心安全问题的话，请尽量避免使用它。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/login"><code>docker login</code></a> 登入仓管中心。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/logout"><code>docker logout</code></a> 登出仓管中心。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/search"><code>docker search</code></a> 从仓管中心检索镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/pull"><code>docker pull</code></a> 从仓管中心拉取镜像到本地。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/push"><code>docker push</code></a> 从本地推送镜像到仓管中心。</li>
</ul>
<h3 id="本地仓管中心"><a href="#本地仓管中心" class="headerlink" title="本地仓管中心"></a>本地仓管中心</h3><p>你可以使用 <a target="_blank" rel="noopener" href="https://github.com/docker/distribution">docker distribution</a> 项目搭建本地的仓管中心，详情参阅 <a target="_blank" rel="noopener" href="https://github.com/docker/docker.github.io/blob/master/registry/deploying.md">本地发布 (local deploy)</a> 的介绍。</p>
<p>科学上网后，也可以看看 <a target="_blank" rel="noopener" href="https://groups.google.com/a/dockerproject.org/forum/#!forum/distribution">Google+ Group</a>。</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>当你执行 <code>docker build</code> 时，Docker 将会根据 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">配置文件</a> 启动 Docker 容器。远优于使用 <code>docker commit</code>。</p>
<p>以下是一些编写 Dockerfile 的常用编辑器，并链接到适配的语法高亮模块︰</p>
<ul>
<li>如果你在使用 <a target="_blank" rel="noopener" href="http://jedit.org/">jEdit</a>，你可以使用我开发的 Dockerfile <a target="_blank" rel="noopener" href="https://github.com/wsargent/jedit-docker-mode">语法高亮模块</a>。</li>
<li>[Sublime Text 2](<a target="_blank" rel="noopener" href="https://packagecontrol.io/packages/Dockerfile">https://packagecontrol.io/packages/Dockerfile</a> Syntax Highlighting)</li>
<li><a target="_blank" rel="noopener" href="https://atom.io/packages/language-docker">Atom</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ekalinin/Dockerfile.vim">Vim</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spotify/dockerfile-mode">Emacs</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker/docker/tree/master/contrib/syntax/textmate">TextMate</a></li>
<li>更多信息请参阅 <a target="_blank" rel="noopener" href="https://domeide.github.io/">Docker 遇上 IDE</a></li>
</ul>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">.dockerignore</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#from">FROM</a> 为其他指令设置基础镜像 (Base Image)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated">MAINTAINER (deprecated - use LABEL instead)</a> 为生成的镜像设置作者字段。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#run">RUN</a> 在当前镜像的基础上生成一个新层并执行命令。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#cmd">CMD</a> 设置容器默认执行命令。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a> 告知 Docker 容器在运行时所要监听的网络端口。注意：并没有实际上将端口设置为可访问。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#env">ENV</a> 设置环境变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#add">ADD</a> 将文件、目录或远程文件复制到容器中。缓存无效。请尽量用 <code>COPY</code> 代替 <code>ADD</code>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#copy">COPY</a> 将文件或文件夹复制到容器中。注意：将使用 ROOT 用户复制文件，故无论 USER &#x2F; WORKDIR 指令如何配置，你都需要手动修改其所有者（<code>chown</code>），<code>ADD</code> 也是一样。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#entrypoint">ENTRYPOINT</a> 将容器设为可执行的。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#volume">VOLUME</a> 在容器内部创建挂载点 (mount point) 指向外部挂载的卷标或其他容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#user">USER</a> 设置随后执行 RUN &#x2F; CMD &#x2F; ENTRYPOINT 命令的用户名。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#workdir">WORKDIR</a> 设置工作目录 (working directory)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#arg">ARG</a> 定义编译时 (build-time) 变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#onbuild">ONBUILD</a> 添加触发指令，当该镜像被作为其他镜像的基础镜像时该指令会被触发。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#stopsignal">STOPSIGNAL</a> 设置停止容器时，向容器内发送的系统调用信号 (system call signal)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/config/labels-custom-metadata/">LABEL</a> 将键值对元数据 (key&#x2F;value metadata) 应用到镜像、容器或是守护进程。</li>
</ul>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><ul>
<li><a target="_blank" rel="noopener" href="http://flux7.com/blogs/docker/docker-tutorial-series-part-3-automation-is-the-word-using-dockerfile/">Flux7’s Dockerfile Tutorial</a></li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#dockerfile-examples">Examples</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li>
<li><a target="_blank" rel="noopener" href="http://crosbymichael.com/">Michael Crosby</a> 还有更多的 <a target="_blank" rel="noopener" href="http://crosbymichael.com/dockerfile-best-practices.html">Dockerfiles best practices</a> &#x2F; <a target="_blank" rel="noopener" href="http://crosbymichael.com/dockerfile-best-practices-take-2.html">take 2</a></li>
<li><a target="_blank" rel="noopener" href="http://jonathan.bergknoff.com/journal/building-good-docker-images">Building Good Docker Images</a> &#x2F; <a target="_blank" rel="noopener" href="http://jonathan.bergknoff.com/journal/building-better-docker-images">Building Better Docker Images</a></li>
<li><a target="_blank" rel="noopener" href="https://speakerdeck.com/garethr/managing-container-configuration-with-metadata">Managing Container Configuration with Metadata</a></li>
</ul>
<h2 id="层-Layers"><a href="#层-Layers" class="headerlink" title="层(Layers)"></a>层(Layers)</h2><p>Docker 的版本化文件系统是基于层的。就像 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/">Git 的提交或文件变更系统</a> 一样。</p>
<h2 id="链接-Links"><a href="#链接-Links" class="headerlink" title="链接(Links)"></a>链接(Links)</h2><p>链接 (links) <a target="_blank" rel="noopener" href="https://docs.docker.com/userguide/dockerlinks/">通过 TCP&#x2F;IP 端口</a> 实现 Docker 容器之间的通讯。<a target="_blank" rel="noopener" href="https://blogs.atlassian.com/2013/11/docker-all-the-things-at-atlassian-automation-and-wiring/">Atlassian</a> 展示了可用的例子。你还可以 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/#/updating-the-etchosts-file">通过主机名 (hostname) 链接</a>。</p>
<p>在某种意义上来说，该特性已经被 <a target="_blank" rel="noopener" href="https://docs.docker.com/network/">自定义网络</a> 所替代。</p>
<p>注意: 如果你希望容器之间<strong>只</strong>通过链接进行通讯，在启动 Docker 守护进程时，请使用 <code>-icc=false</code> 来禁用内部进程通讯。</p>
<p>假设你有一个名为 CONTAINER 的容器（通过 <code>docker run --name CONTAINER</code> 指定）并且在 Dockerfile 中，暴露了一个端口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 1337</span><br></pre></td></tr></table></figure>

<p>然后，我们创建另外一个名为 LINKED 的容器:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --link CONTAINER:ALIAS --name LINKED user/wordpress</span><br></pre></td></tr></table></figure>

<p>然后 CONTAINER 暴露的端口和别名将会以如下的环境变量出现在 LINKED 中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ALIAS_PORT_1337_TCP_PORT</span><br><span class="line">$ALIAS_PORT_1337_TCP_ADDR</span><br></pre></td></tr></table></figure>

<p>那么你便可以通过这种方式来连接它了。</p>
<p>使用 <code>docker rm --link</code> 即可删除链接。</p>
<p>通常，Docker 容器（亦可理解为「服务」）之间的链接，是「服务发现」的一个子集。如果你打算在生产中大规模使用 Docker，这将是一个很大的问题。请参阅<a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-service-discovery-and-distributed-configuration-stores">The Docker Ecosystem: Service Discovery and Distributed Configuration Stores</a> 获取更多信息。</p>
<h2 id="卷标-Volumes-和挂载"><a href="#卷标-Volumes-和挂载" class="headerlink" title="卷标(Volumes)和挂载"></a>卷标(Volumes)和挂载</h2><h3 id="卷标"><a href="#卷标" class="headerlink" title="卷标"></a>卷标</h3><p>Docker 的卷标 (volumes) 是 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockervolumes/">独立的文件系统</a>。它们并非必须连接到特定的容器上。</p>
<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<p>卷标相关命令：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_create/"><code>docker volume create</code></a> - 创建卷标</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_rm/"><code>docker volume rm</code></a> - 删除卷标</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_ls/"><code>docker volume ls</code></a> - 查看卷标</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_inspect/"><code>docker volume inspect</code></a> - 查看数据卷的具体信息</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_prune/"><code>docker volume prune</code></a> -  清理无主的数据卷</p>
</li>
</ul>
<p>卷标在不能使用链接（只有 TCP&#x2F;IP）的情况下非常有用。例如，如果你有两个 Docker 实例需要通讯并在文件系统上留下记录。</p>
<p>你可以一次性将其挂载到多个 docker 容器上，通过 <code>docker run --volumes-from</code>。</p>
<p>因为卷标是独立的文件系统，它们通常被用于存储各容器之间的瞬时状态。也就是说，你可以配置一个无状态临时容器，关掉之后，当你有第二个这种临时容器实例的时候，你可以从上一次保存的状态继续执行。</p>
<p>查看 <a target="_blank" rel="noopener" href="http://crosbymichael.com/advanced-docker-volumes.html">卷标进阶</a> 来获取更多细节。<a target="_blank" rel="noopener" href="http://container42.com/2014/11/03/docker-indepth-volumes/">Container42</a> 非常有用。</p>
<p>你可以 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume">将宿主 MacOS 的文件夹映射为 Docker 卷标</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /Users/wsargent/myapp/src:/src</span><br></pre></td></tr></table></figure>

<p>你也可以用远程 NFS 卷标，如果你觉得你 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockervolumes/#/mount-a-shared-storage-volume-as-a-data-volume">有足够勇气</a>。</p>
<p>还可以考虑运行一个纯数据容器，像 <a target="_blank" rel="noopener" href="http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/">这里</a> 所说的那样，提供可移植数据。</p>
<p>记得，<a target="_blank" rel="noopener" href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn#%E5%B0%86%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD%E4%B8%BA%E5%8D%B7%E6%A0%87">文件也可以被挂载为卷标</a>。</p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。 </p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。 </p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>这里有一些最佳实践，以及争论焦点：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://gregoryszorc.com/blog/2014/10/16/the-rabbit-hole-of-using-docker-in-automated-tests/">The Rabbit Hole of Using Docker in Automated Tests</a></li>
<li><a target="_blank" rel="noopener" href="https://twitter.com/bridgetkromhout">Bridget Kromhout</a> has a useful blog post on <a target="_blank" rel="noopener" href="http://sysadvent.blogspot.co.uk/2014/12/day-1-docker-in-production-reality-not.html">running Docker in production</a> at Dramafever.</li>
<li>There’s also a best practices <a target="_blank" rel="noopener" href="http://developers.lyst.com/devops/2014/12/08/docker/">blog post</a> from Lyst.</li>
<li><a target="_blank" rel="noopener" href="https://engineering.salesforceiq.com/2013/11/05/a-docker-dev-environment-in-24-hours-part-2-of-2.html">A Docker Dev Environment in 24 Hours!</a></li>
<li><a target="_blank" rel="noopener" href="https://tersesystems.com/2013/11/20/building-a-development-environment-with-docker/">Building a Development Environment With Docker</a></li>
<li><a target="_blank" rel="noopener" href="https://samsaffron.com/archive/2013/11/07/discourse-in-a-docker-container">Discourse in a Docker Container</a></li>
</ul>
<h2 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全(Security)"></a>安全(Security)</h2><p>这节准备讨论一些关于 Docker 安全性的问题。Docker 官方文档 <a target="_blank" rel="noopener" href="https://docs.docker.com/articles/security/">安全</a> 页面讲述了更多细节。</p>
<p>首先第一件事：Docker 是有 root 权限的。如果你在 <code>docker</code> 组，那么你就有 <a target="_blank" rel="noopener" href="https://web.archive.org/web/20161226211755/http://reventlov.com/advisories/using-the-docker-command-to-root-the-host">root 权限</a>。如果你将 Docker 的 Unix Socket 暴露给容器，意味着你赋予了容器 <a target="_blank" rel="noopener" href="https://www.lvh.io/posts/dont-expose-the-docker-socket-not-even-to-a-container.html">宿主机 root 权限</a>。</p>
<p>Docker 不应当作为唯一的防御措施。你应当使其更加安全可靠。</p>
<p>为了更好地理解容器暴露了什么，可参阅由 <a target="_blank" rel="noopener" href="https://twitter.com/dyn___">Aaron Grattafiori</a> 编写的 <a target="_blank" rel="noopener" href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf">Understanding and Hardening Linux Containers</a>。这是一个完整全面且包含大量链接和脚注的容器问题指南，介绍了许多有用的内容。即使你已经加固过容器，以下的安全提示依然十分有帮助，但并不能代替理解的过程。</p>
<h3 id="安全提示"><a href="#安全提示" class="headerlink" title="安全提示"></a>安全提示</h3><p>为了最大的安全性，你应当考虑在虚拟机上运行 Docker。这是直接从 Docker 安全团队拿来的资料 – <a target="_blank" rel="noopener" href="http://www.slideshare.net/jpetazzo/linux-containers-lxc-docker-and-security">slides</a> &#x2F; <a target="_blank" rel="noopener" href="http://www.projectatomic.io/blog/2014/08/is-it-safe-a-look-at-docker-and-security-from-linuxcon/">notes</a>。之后，可使用 AppArmor、seccomp、SELinux、grsec 等来 <a target="_blank" rel="noopener" href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/">限制容器的权限</a>。更多细节，请查阅 <a target="_blank" rel="noopener" href="https://blog.docker.com/2016/02/docker-engine-1-10-security/">Docker 1.10 security features</a>。</p>
<p>Docker 镜像 ID 属于 <a target="_blank" rel="noopener" href="https://medium.com/@quayio/your-docker-image-ids-are-secrets-and-its-time-you-treated-them-that-way-f55e9f14c1a4">敏感信息</a> 所以它不应该向外界公开。请将它们当作密码来对待。</p>
<p>阅读由 <a target="_blank" rel="noopener" href="https://github.com/konstruktoid">Thomas Sjögren</a> 编写的 <a target="_blank" rel="noopener" href="https://github.com/konstruktoid/Docker/blob/master/Security/CheatSheet.adoc">Docker Security Cheat Sheet</a>：关于加固容器的不错的建议。</p>
<p>查看 <a target="_blank" rel="noopener" href="https://github.com/docker/docker-bench-security">Docker 安全测试脚本</a>，下载 <a target="_blank" rel="noopener" href="https://blog.docker.com/2015/05/understanding-docker-security-and-best-practices/">最佳实践白皮书</a>。</p>
<p>你应当远离使用非稳定版本 grsecurity &#x2F; pax 的内核，比如 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Alpine_Linux">Alpine Linux</a>。如果在产品中用了 grsecurity，那么你应该考虑使用有 <a target="_blank" rel="noopener" href="https://grsecurity.net/business_support.php">商业支持</a> 的 <a target="_blank" rel="noopener" href="https://grsecurity.net/announce.php">稳定版本</a>，就像你对待 RedHat 那样。虽然要 $200 每月，但对于你的运维预算来说不值一提。</p>
<p>从 Docker 1.11 开始，你可以轻松的限制在容器中可用的进程数，以防止 fork 炸弹。 这要求 Linux 内核 &gt;&#x3D; 4.3，并且要在内核配置中打开 CGROUP_PIDS&#x3D;y。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --pids-limit=64</span><br></pre></td></tr></table></figure>

<p>同时，你也可以限制进程再获取新权限。该功能是 Linux 内核从 3.5 版本开始就拥有的。你可以从 <a target="_blank" rel="noopener" href="http://www.projectatomic.io/blog/2016/03/no-new-privs-docker/">这篇博客</a> 中阅读到更多关于这方面的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --security-opt=no-new-privileges</span><br></pre></td></tr></table></figure>

<p>以下内容摘选自 <a target="_blank" rel="noopener" href="http://container-solutions.com/is-docker-safe-for-production/">Container Solutions</a> 的 <a target="_blank" rel="noopener" href="http://container-solutions.com/content/uploads/2015/06/15.06.15_DockerCheatSheet_A2.pdf">Docker Security Cheat Sheet</a>（PDF 版本，难以使用，故复制至此）：</p>
<p>关闭内部进程通讯：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d --icc=false --iptables</span><br></pre></td></tr></table></figure>

<p>设置容器为只读：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --read-only</span><br></pre></td></tr></table></figure>

<p>通过 hashsum 来验证卷标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull debian@sha256:a25306f3850e1bd44541976aa7b5fd0a29be</span><br></pre></td></tr></table></figure>

<p>设置卷标为只读：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v $(pwd)/secrets:/secrets:ro debian</span><br></pre></td></tr></table></figure>

<p>在 Dockerfile 中定义用户并以该用户运行，避免在容器中以 ROOT 身份操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r user &amp;&amp; useradd -r -g user user</span><br><span class="line">USER user</span><br></pre></td></tr></table></figure>

<h3 id="用户命名空间-User-Namespaces"><a href="#用户命名空间-User-Namespaces" class="headerlink" title="用户命名空间(User Namespaces)"></a>用户命名空间(User Namespaces)</h3><p>还可以通过使用 <a target="_blank" rel="noopener" href="https://s3hh.wordpress.com/2013/07/19/creating-and-using-containers-without-privilege/">用户命名空间</a> – 自 1.10 版本起已内置，但默认并未启用。</p>
<p>要在 Ubuntu 15.10 中启用用户命名空间 (remap the userns)，请 <a target="_blank" rel="noopener" href="https://raesene.github.io/blog/2016/02/04/Docker-User-Namespaces/">跟着这篇博客的例子</a> 来做。</p>
<h3 id="安全相关视频"><a href="#安全相关视频" class="headerlink" title="安全相关视频"></a>安全相关视频</h3><ul>
<li><a target="_blank" rel="noopener" href="https://youtu.be/04LOuMgNj9U">Using Docker Safely</a></li>
<li><a target="_blank" rel="noopener" href="https://youtu.be/KmxOXmPhZbk">Securing your applications using Docker</a></li>
<li><a target="_blank" rel="noopener" href="https://youtu.be/a9lE9Urr6AQ">Container security: Do containers actually contain?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=iN6QbszB1R8">Linux Containers: Future or Fantasy?</a></li>
</ul>
<h3 id="安全路线图"><a href="#安全路线图" class="headerlink" title="安全路线图"></a>安全路线图</h3><p>Docker 的路线图提到关于 <a target="_blank" rel="noopener" href="https://github.com/docker/docker/blob/master/ROADMAP.md#11-security">seccomp 的支持</a>。 一个名为 <a target="_blank" rel="noopener" href="https://github.com/jfrazelle/bane">bane</a> 的 AppArmor 策略生成器正在实现 <a target="_blank" rel="noopener" href="https://github.com/docker/docker/issues/17142">安全配置文件</a>。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://sssslide.com/speakerdeck.com/bmorearty/15-docker-tips-in-5-minutes">15 Docker Tips in 5 minutes</a></li>
<li><a target="_blank" rel="noopener" href="https://codefresh.io/blog/everyday-hacks-docker/">CodeFresh Everyday Hacks Docker</a></li>
</ul>
<h3 id="清理-1"><a href="#清理-1" class="headerlink" title="清理"></a>清理</h3><p>最新的 <a target="_blank" rel="noopener" href="https://github.com/docker/docker/pull/26108">数据管理命令</a> 已在 Docker 1.13 实现：</p>
<ul>
<li><code>docker system prune</code></li>
<li><code>docker volume prune</code></li>
<li><code>docker network prune</code></li>
<li><code>docker container prune</code></li>
<li><code>docker image prune</code></li>
</ul>
<h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><p><code>docker system df</code> 将显示当前 Docker 各部分占用的磁盘空间。</p>
<h3 id="Heredoc-声明-Docker-容器"><a href="#Heredoc-声明-Docker-容器" class="headerlink" title="Heredoc 声明 Docker 容器"></a>Heredoc 声明 Docker 容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t htop - &lt;&lt; EOF</span><br><span class="line">FROM alpine</span><br><span class="line">RUN apk --no-cache add htop</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="最近一次的容器-ID"><a href="#最近一次的容器-ID" class="headerlink" title="最近一次的容器 ID"></a>最近一次的容器 ID</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias dl=&#x27;docker ps -l -q&#x27;</span><br><span class="line">docker run ubuntu echo hello world</span><br><span class="line">docker commit $(dl) helloworld</span><br></pre></td></tr></table></figure>

<h3 id="带命令的提交（需要-Dockerfile）"><a href="#带命令的提交（需要-Dockerfile）" class="headerlink" title="带命令的提交（需要 Dockerfile）"></a>带命令的提交（需要 Dockerfile）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -run=&#x27;&#123;&quot;Cmd&quot;:[&quot;postgres&quot;, &quot;-too -many -opts&quot;]&#125;&#x27; $(dl) postgres</span><br></pre></td></tr></table></figure>

<h3 id="获取-IP-地址"><a href="#获取-IP-地址" class="headerlink" title="获取 IP 地址"></a>获取 IP 地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | grep -wm1 IPAddress | cut -d &#x27;&quot;&#x27; -f 4</span><br></pre></td></tr></table></figure>

<p>或使用 <a target="_blank" rel="noopener" href="https://stedolan.github.io/jq/">jq</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | jq -r &#x27;.[0].NetworkSettings.IPAddress&#x27;</span><br></pre></td></tr></table></figure>

<p>或使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/inspect">go 模板</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; &lt;container_name&gt;</span><br></pre></td></tr></table></figure>

<p>或在通过 Dockerfile 构建镜像时，通过构建参数 (build argument) 传入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_HOST_IP=`ifconfig | grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; | grep -v 127.0.0.1 | awk &#x27;&#123; print $2 &#125;&#x27; | cut -f2 -d: | head -n1`</span><br><span class="line">echo DOCKER_HOST_IP = $DOCKER_HOST_IP</span><br><span class="line">docker build \</span><br><span class="line">  --build-arg ARTIFACTORY_ADDRESS=$DOCKER_HOST_IP</span><br><span class="line">  -t sometag \</span><br><span class="line">  some-directory/</span><br></pre></td></tr></table></figure>

<h3 id="获取端口映射"><a href="#获取端口映射" class="headerlink" title="获取端口映射"></a>获取端口映射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123;range $p, $conf := .NetworkSettings.Ports&#125;&#125; &#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;(index $conf 0).HostPort&#125;&#125; &#123;&#123;end&#125;&#125;&#x27; &lt;containername&gt;</span><br></pre></td></tr></table></figure>

<h3 id="通过正则匹配容器"><a href="#通过正则匹配容器" class="headerlink" title="通过正则匹配容器"></a>通过正则匹配容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(docker ps -a | grep &quot;REGEXP_PATTERN&quot; | cut -f1 -d&quot; &quot;); do echo $i; done`</span><br></pre></td></tr></table></figure>

<h3 id="获取环境变量配置"><a href="#获取环境变量配置" class="headerlink" title="获取环境变量配置"></a>获取环境变量配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm ubuntu env</span><br></pre></td></tr></table></figure>

<h3 id="强行终止运行中的容器"><a href="#强行终止运行中的容器" class="headerlink" title="强行终止运行中的容器"></a>强行终止运行中的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill $(docker ps -q)</span><br></pre></td></tr></table></figure>

<h3 id="删除所有容器（强行删除！无论容器运行或停止）"><a href="#删除所有容器（强行删除！无论容器运行或停止）" class="headerlink" title="删除所有容器（强行删除！无论容器运行或停止）"></a>删除所有容器（强行删除！无论容器运行或停止）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -qa)</span><br></pre></td></tr></table></figure>

<h3 id="删除旧容器"><a href="#删除旧容器" class="headerlink" title="删除旧容器"></a>删除旧容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep &#x27;weeks ago&#x27; | awk &#x27;&#123;print $1&#125;&#x27; | xargs docker rm</span><br></pre></td></tr></table></figure>

<h3 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v `docker ps -a -q -f status=exited`</span><br></pre></td></tr></table></figure>

<h3 id="停止并删除容器"><a href="#停止并删除容器" class="headerlink" title="停止并删除容器"></a>停止并删除容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq) &amp;&amp; docker rm -v $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<h3 id="删除无用-dangling-的镜像"><a href="#删除无用-dangling-的镜像" class="headerlink" title="删除无用 (dangling) 的镜像"></a>删除无用 (dangling) 的镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling=true)</span><br></pre></td></tr></table></figure>

<h3 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>

<h3 id="删除无用-dangling-的卷标"><a href="#删除无用-dangling-的卷标" class="headerlink" title="删除无用 (dangling) 的卷标"></a>删除无用 (dangling) 的卷标</h3><p>Docker 1.9 版本起：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm $(docker volume ls -q -f dangling=true)</span><br></pre></td></tr></table></figure>

<p>1.9.0 中，参数 <code>dangling=false</code> 居然 <em>没</em> 用 - 它会被忽略然后列出所有的卷标。</p>
<h3 id="查看镜像依赖"><a href="#查看镜像依赖" class="headerlink" title="查看镜像依赖"></a>查看镜像依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -viz | dot -Tpng -o docker.png</span><br></pre></td></tr></table></figure>

<h3 id="Docker-容器瘦身"><a href="#Docker-容器瘦身" class="headerlink" title="Docker 容器瘦身"></a>Docker 容器瘦身</h3><ul>
<li>在某层 (RUN layer) 清理 APT</li>
</ul>
<p>这应当和其他 apt 命令在同一层中完成。 否则，前面的层将会保持原有信息，而你的镜像则依旧臃肿。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN &#123;apt commands&#125; \</span><br><span class="line">  &amp;&amp; apt-get clean \</span><br><span class="line">  &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</span><br></pre></td></tr></table></figure>

<ul>
<li>压缩镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID=$(docker run -d image-name /bin/bash)</span><br><span class="line">docker export $ID | docker import – flat-image-name</span><br></pre></td></tr></table></figure>

<ul>
<li>备份</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID=$(docker run -d image-name /bin/bash)</span><br><span class="line">(docker export $ID | gzip -c &gt; image.tgz)</span><br><span class="line">gzip -dc image.tgz | docker import - flat-image-name</span><br></pre></td></tr></table></figure>

<h3 id="监视运行中容器的系统资源利用率"><a href="#监视运行中容器的系统资源利用率" class="headerlink" title="监视运行中容器的系统资源利用率"></a>监视运行中容器的系统资源利用率</h3><p>检查某个容器的 CPU、内存以及网络 I&#x2F;O 使用情况，你可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p>按 ID 列出所有容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps -q)</span><br></pre></td></tr></table></figure>

<p>按名称列出所有容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps --format &#x27;&#123;&#123;.Names&#125;&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>按指定镜像名称列出所有容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -f ancestor=ubuntu</span><br></pre></td></tr></table></figure>

<p>删除所有未标签命名 (untagged) 的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep “^” | awk &#x27;&#123;split($0,a,&quot; &quot;); print a[3]&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>通过正则匹配删除指定容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep wildfly | awk &#x27;&#123;print $1&#125;&#x27; | xargs docker rm -f</span><br></pre></td></tr></table></figure>

<p>删除所有已退出 (exited) 的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a | grep Exit | awk &#x27;&#123; print $1 &#125;&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="将文件挂载为卷标"><a href="#将文件挂载为卷标" class="headerlink" title="将文件挂载为卷标"></a>将文件挂载为卷标</h3><p>文件也可以被挂载为卷标。例如你可以仅仅注入单个配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从容器复制文件</span></span><br><span class="line">docker run --<span class="built_in">rm</span> httpd <span class="built_in">cat</span> /usr/local/apache2/conf/httpd.conf &gt; httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载修改后的配置启动容器</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -ti -v <span class="string">&quot;<span class="variable">$PWD</span>/httpd.conf:/usr/local/apache2/conf/httpd.conf:ro&quot;</span> -p <span class="string">&quot;80:80&quot;</span> httpd</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn">Docker Cheat Sheet</a></li>
</ul>



<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/09/28/Linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/lamp/php.ini/">php.ini</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/09/28/Linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/docker/docker-dockerfile/">docker-dockerfile</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
